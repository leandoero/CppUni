#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int n, g, h;
    cin >> n >> g >> h;

    vector<pair<int, int>> orcs(n);
    for (int i = 0; i < n; i++) {
        cin >> orcs[i].first >> orcs[i].second;
    }

    // Проверяем, можно ли собрать отряд
    if (g + h > n) {
        cout << -1;
        return 0;
    }

    // Сортируем орков по выгодности быть grunt'ом
    sort(orcs.begin(), orcs.end(), [](auto a, auto b) {
        return (a.first - a.second) > (b.first - b.second);
        });

    int sum = 0;

    // Берем лучших grunt'ов
    for (int i = 0; i < g; i++) {
        sum += orcs[i].first;
    }

    // Берем лучших headhunter'ов
    for (int i = n - 1; i >= n - h; i--) {
        sum += orcs[i].second;
    }

    // Остальные выбирают где лучше
    for (int i = g; i < n - h; i++) {
        sum += max(orcs[i].first, orcs[i].second);
    }

    cout << sum;
    return 0;
}

/*
Дополнительный пример (для понимания):
Входные данные:

5 2 1
10 1
8 2
5 5
3 7
1 10
Шаги выполнения:

Читаем данные: n=5, g=2, h=1

Проверка: 2+1 ≤ 5 → можно создать отряд

Список орков до сортировки: [(10,1), (8,2), (5,5), (3,7), (1,10)]

Сортируем по (ближний бой - метание):

Разницы: 9, 6, 0, -4, -9

После сортировки: [(10,1), (8,2), (5,5), (3,7), (1,10)]

Назначаем grunts (g=2): берём первых двух → 10 + 8 = 18

Назначаем headhunters (h=1): берём последнего → 10

Обрабатываем оставшихся (орки 3 и 4):

max(5,5)=5

max(3,7)=7

Сумма: 18 (grunts) + 10 (headhunter) + 5 + 7 = 40

Вывод: 40

Как работает сортировка:
Сортировка по (ближний бой - метание) помогает определить:

В начале списка - орки, которых выгоднее сделать grunts (большая положительная разница)

В конце списка - орки, которых выгоднее сделать headhunters (большая отрицательная разница)

В середине - орки, которые примерно одинаковы в обеих специализациях

Это позволяет оптимально распределить роли и получить максимальную суммарную силу отряда.

*/